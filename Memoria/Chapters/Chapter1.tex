\Chapter{Problema a investigar}{Análisis, implementación y optimización}
\index{Problema a investigar}

\section{Job Shop Scheduling Problem}
\index{Job Shop Scheduling Problem}

Se estudia la implementación de una solución al problema
\italic{Job Shop Scheduling (JSP)}~\cite{Yan77}
\footnote{El problema también es conocido por otros nombres similares
como \italic{Job Shop Scheduling Problem (JSSP)} o Job Scheduling Problem (JSP).}
utilizando el algoritmo A*.
Como su nombre indica, se trata de un problema en el que se debe
crear una planificación.
Como se especifica en la literatura, el JSP es un problema de optimización np-hard.

El JSP busca una planificación para una serie de
máquinas (o trabajadores) que deben realizar un número conocido
de trabajos.
Cada trabajo está formado por una serie de operaciones (o tareas),
con una duración conocida.
Las tareas de un mismo trabajo deben ser ejecutadas en un orden específico.

Existen numerosas variantes de este problema,
algunas permiten la ejecución
en paralelo de algunas tareas o requieren que alguna tarea
en específico sea ejecutada por un trabajador (o tipo de trabajador)
en particular.
Por ello, es clave denotar las restricciones que definen el problema JSP\@:

\begin{enumerate}[start=0, itemsep=0.25px]
    \item Existen un número natural conocido de trabajos.
    \item A excepción de la primera tarea de cada trabajo,
    todas tienen una única tarea predecesora del mismo trabajo
    que debe ser completada antes de iniciar su ejecución.
    \item Cada tarea puede tener una duración distinta.
    \item La duración de cada tarea es un número natural conocido.
    \item Existe un número natural conocido de trabajadores.
    \item Cada tarea tiene un trabajador asignado,
    de forma que sólo ese trabajador puede ejecutar la tarea.
    \item Una vez iniciada una tarea, no se puede interrumpir su ejecución.
    \item Un mismo trabajador puede intercalar la ejecución de tareas de diferentes trabajos.
    \item Un trabajador sólo puede realizar una tarea al mismo tiempo.
    \item Los tiempos de preparación de un trabajador antes de realizar una tarea son nulos.
    \item Los tiempos de espera entre la realización de una tarea y otra son nulos.
\end{enumerate}

\subsection{Notación}

Con el objetivo de simplicar los ejemplos contenidos en este documento
se ha diseñado una notación capaz de describir trabajos, tareas y estados.
A continuación se encuentra una explicación de dicha notación
necesaria para comprender correctamente los ejemplos.

\subsubsection{Tarea}

Una tarea está compuesta por dos datos: La duración y el trabajador que la debe ejecutar:
$(A, B)$ donde $A$ es la duración y $B$ el ID del trabajador.
$(5, 0)$ es una tarea que dura $5$ instantes de tiempo y debe ser ejecutada por el
trabajador $0$.

\subsubsection{Trabajo}

Un trabajo está compuesto por un listado de tareas.
$(A, B), (C, D)$ es un trabajo compuesto por dos tareas:
$(A, B)$ es una tarea que dura $A$ instantes de tiempo y debe ser ejecutada por $B$ y
$(C, D)$ es una tarea que dura $C$ instantes de tiempo y debe ser ejecutada por $D$.

\subsubsection{Conjunto de datos}

Un conjunto de datos está compuesto por un listado de trabajos:
\begin{enumerate}[start=0, itemsep=0.25px]
    \item (A, B), (C, D)
    \item (E, F), (G, H)
\end{enumerate}
El conjunto está compuesto por dos trabajos (IDs 0 y 1) cada uno con dos tareas.
Para referirse a la tarea (A, B) se utilizaría T00 (Trabajo 0, tarea 0)
mientras que para la tarea (G, H) se utilizaría T11 (Trabajo 1, tarea 1).
Adicionalmente, se podrá añadir la duración de la tarea a esta notación:
T00(A) corresponde al trabajo 0, tarea 0 con duración A instantes de tiempo.

\subsubsection{Planificación}

La planificación es un dato propio del estado.
Indica el instante de tiempo en el que se inicia cada tarea:
$(0, 3, -1)$ indica que la tarea 0 se inicia en el instante 0,
la 1 en el 3 y la 2 aún está sin planificar.

Generalmente se muestra la planificación de todo el conjunto de datos
utilizando un listado:
\begin{enumerate}[start=0, itemsep=0.25px]
    \item $(0, 3, -1)$
    \item $(0, -1, -1)$
\end{enumerate}
La T00 se inicia en el instante 0 mientras que la T11 está aún sin planificar.

\subsubsection{Estado trabajadores}

Propio también del estado es la información sobre
el instante de tiempo en el que cada trabajador quedará libre.
Estos datos se muestran en forma de lista donde el elemento $K$
corresponde al instante de tiempo donde el trabajador con ID $K$
queda libre.
$(2, 8, 0)$ indica que el trabajador 0 esta libre a partir del instante 2,
el 1 a partir del 8 y el 2 a partir del 0.

\pagebreak
\subsection{Ejemplo}
\label{ssec:A*Example}

A continuación se muestra un ejemplo de menor tamaño resuelto manualmente
donde cada línea corresponde a un trabajo y cada tupla al par (duración, trabajador).

\begin{enumerate}[start=0, itemsep=0.25px]
    \item (2, 0), (5, 1), (1, 2)
    \item (3, 1), (3, 2), (3, 0)
\end{enumerate}

Se crea un diagrama Gantt (figura \ref{fig:ExampleGantt}) donde cada arco es una tarea,
ignorando a los trabajadores,
atendiendo únicamente a la duración de cada tarea.
Los arcos están etiquetados con la tarea a ejecutar y su duración.
Los nodos contienen dos números: el primero corresponde al primer instante de tiempo
en el que la tarea se puede ejecutar y el segundo al último
(tiempos \italic{early} y \italic{late}).

\begin{figure}[h]
    \begin{center}
        \begin{tikzpicture}[node distance=4cm]
            % \node (08) [dot, right of=06, xshift=4cm] {\lstinline{n_2}};
            % \draw [arrow] (01.south) to node [anchor=west] {\lstinline{pop()}} (04);
            % \draw [arrow] (04.south) to node [anchor=west] {\lstinline{process()}} (06);
            % \draw [arrow] (06.west) to [bend left] node [anchor=north] {\lstinline{neighbor_0}} (05);

            \node (A) [dot] {0, 0};

            \node (B) [dot, right of=A, above of=A] {2, 3};
            \node (C) [dot, right of=A, below of=A] {3, 3};

            \node (D) [dot, right of=B] {7, 8};
            \node (E) [dot, right of=C] {6, 6};

            \node (F) [dot, right of=D, below of=D] {9, 9};

            \draw [arrow] (A.east) to node [anchor=south east] {T00(2)} (B);
            \draw [arrow] (A.east) to node [anchor=north east] {T10(3)} (C);

            \draw [arrow] (B.east) to node [anchor=south] {T01(5)} (D);
            \draw [arrow] (C.east) to node [anchor=north] {T11(3)} (E);

            \draw [arrow] (D.east) to node [anchor=south west] {T02(1)} (F);
            \draw [arrow] (E.east) to node [anchor=north west] {T12(3)} (F);
        \end{tikzpicture}
    \end{center}
    \caption{Diagrama Gantt ejemplo.}
    \label{fig:ExampleGantt}
\end{figure}

El diagrama siguiente (\ref{fig:PlanificacionEjemplo}) tiene en cuenta la disponibilidad de cada trabajador,
nótese que la tarea T01 comienza en el instante 3 en lugar del 2,
esto se debe a que el trabajador no está disponible hasta ese instante.
Los nodos del diagrama muestran el instante de inicio de la tarea,
la tarea y su duración y el instante de fin.
Cada trabajador tiene asignado un color distinto,
por lo que no es posible que dos tareas del mismo color
se encuentren planificadas en el mismo instante de tiempo.

\begin{figure}[h]
    \begin{center}
        \begin{tikzpicture}[node distance=4cm]
            \node (T00) [dot] at (0, 12) {T00};
            \node (T01) [dot] at (0, 10) {T01};
            \node (T02) [dot] at (0, 8) {T02};

            \node (T10) [dot] at (0, 4) {T10};
            \node (T11) [dot] at (0, 2) {T11};
            \node (T12) [dot] at (0, 0) {T12};

            \node (00) [process, fill=yellow!60] at(4, 12) {0 - T00(2) - 2};
            \node (10) [process, fill=green!60] at(4, 4) {0 - T10(3) - 3};

            \node (01) [process, fill=green!60] at(8, 10) {3 - T01(5) - 8};
            \node (11) [process, fill=red!60] at(8, 2) {3 - T11(3) - 6};

            \node (02) [process, fill=red!60] at(12, 8) {8 - T02(1) - 9};
            \node (12) [process, fill=yellow!60] at(12, 0) {6 - T12(3) - 9};
        \end{tikzpicture}
    \end{center}
    \caption{Planificación ejemplo.}
    \label{fig:PlanificacionEjemplo}
\end{figure}

\pagebreak
\section{Método de resolución}

\subsection{El Algoritmo A*}
\index{Algoritmo A*}

Existen numerosos algoritmos capaces de resolver el problema del JSP\@.
Estrategias más simples como listas ordenadas en función de la duración
de los trabajos, algoritmos genéticos, técnicas gráficas,
algoritmos \italic{Branch and Bound} y heurísticos.
En este estudio se utilizará un algoritmo heurístico, A* (\italic{A star})~\cite{HNR68}
para resolver el problema JSP\@.

El A* es una evolución del algoritmo de Dijkstra.
Su principal diferencia es la implementación de una función heurística
que se utiliza para decidir el siguiente nodo a expandir.
De esta forma, se podría decir que el algoritmo A* va `guiado'
hacia la solución, mientras que el algoritmo de Dijkstra
sigue los caminos con menor coste (Véase figura \ref{fig:DijkstraA*Comparison}).

\begin{figure}[h]
\begin{subfigure}{.5\textwidth}
\begin{center}
\begin{tikzpicture}[node distance=1.5cm]
    \node (00) [dot, fill=green!30] {00};
    \node (01) [dot, right of=00, fill=blue!30] {01};
    \node (02) [dot, right of=01] {02};
    \node (03) [dot, right of=02, fill=blue!30] {03};

    \node (10) [dot, below of=00] {10};
    \node (11) [dot, right of=10, fill=blue!30] {11};
    \node (12) [dot, right of=11, fill=blue!30] {12};
    \node (13) [dot, right of=12, fill=blue!30] {13};

    \node (20) [dot, below of=10] {20};
    \node (21) [dot, right of=20] {21};
    \node (22) [dot, right of=21, fill=blue!30] {22};
    \node (23) [dot, right of=22] {23};

    \node (30) [dot, below of=20] {30};
    \node (31) [dot, right of=30, fill=blue!30] {31};
    \node (32) [dot, right of=31, fill=blue!30] {32};
    \node (33) [dot, right of=32, fill=yellow!30] {33};

    \draw [arrow] (00) -- (11);
    \draw [arrow] (00) -- (01);

    \draw [arrow] (11) -- (22);
    \draw [arrow] (11) -- (12);
    \draw [arrow] (12) -- (13);
    \draw [arrow] (13) -- (03);

    \draw [arrow] (22) -- (33);
    \draw [arrow] (22) -- (32);

    \draw [arrow] (32) -- (31);
\end{tikzpicture}
\subcaption{Algoritmo Dijkstra}
\end{center}
\end{subfigure}
\begin{subfigure}{.5\textwidth}
\begin{center}
\begin{tikzpicture}[node distance=1.5cm]
    \node (00) [dot, fill=green!30] {00};
    \node (01) [dot, right of=00] {01};
    \node (02) [dot, right of=01] {02};
    \node (03) [dot, right of=02] {03};

    \node (10) [dot, below of=00] {10};
    \node (11) [dot, right of=10, fill=blue!30] {11};
    \node (12) [dot, right of=11] {12};
    \node (13) [dot, right of=12] {13};

    \node (20) [dot, below of=10] {20};
    \node (21) [dot, right of=20] {21};
    \node (22) [dot, right of=21, fill=blue!30] {22};
    \node (23) [dot, right of=22] {23};

    \node (30) [dot, below of=20] {30};
    \node (31) [dot, right of=30] {31};
    \node (32) [dot, right of=31] {32};
    \node (33) [dot, right of=32, fill=yellow!30] {33};

    \draw [arrow] (00) -- (11);
    \draw [arrow] (11) -- (22);
    \draw [arrow] (22) -- (33);
\end{tikzpicture}
\subcaption{Algoritmo A*}
\end{center}
\end{subfigure}
\caption{Comparativa entre algoritmos Dijkstra y A*}
\label{fig:DijkstraA*Comparison}
\end{figure}

El algoritmo A* utiliza varios componentes para resolver problemas
de optimización. A continuación se describe cada uno de ellos.

\pagebreak

\subsubsection{Pseudocódigo}
\index{Algoritmo A*!Pseudocódigo}

\begin{lstlisting}[language=Python, caption=Pseudocódigo del algoritmo A*, label=lst:PseudocodigoA*]
    lista_abierta = SortedList()
    lista_abierta.append(estado_inicial)

    g_costes = {estado_inicial: 0}
    f_costes = {estado_inicial: calcular_h_coste(estado_inicial)}

    while (not lista_abierta.empty()):
        estado_actual = lista_abierta.pop()

        if (estado_actual == estado_final):
            return estado_actual

        estados_sucesores = calcular_sucesores(estado_actual)

        for estado_sucesor in estados_sucesores:
            sucesor_g_coste = calcular_g_coste(estado_sucesor)
            if (sucesor_g_coste < g_costes[estado_sucesor]):
                g_costes[estado_sucesor] = sucesor_g_coste
                f_costes[estado_sucesor] = sucesor_g_coste + calcular_h_coste(estado_sucesor)
                if (estado_sucesor not in lista_abierta):
                    lista_abierta.append(estado_sucesor)
\end{lstlisting}

El algoritmo (véase pseudocódigo \ref{lst:PseudocodigoA*}) utiliza una lista de estados a explorar
inicialmente compuesta por el estado inicial (ln1-2).
Además, se crean estructuras de datos diseñadas para almacenar
el mejor coste conocido para llegar a un estado cualquiera (ln4-5).
De esta forma, \lstinline{g_costes[estado_a]} es el mejor coste G
conocido hasta el momento para el \lstinline{estado_a}.

El resto del algoritmo se encarga de explorar los nodos
de la lista hasta que esté vacía o el estado actual sea el objetivo.
Si el estado actual es el objetivo, el algoritmo retorna (ln13).
En otro caso, calcula los sucesores del estado actual
y los procesa individualmente (ln16).
Si el coste G del sucesor es mejor que el mejor coste G
conocido para llegar al estado sucesor
se graban sus costes y se añade a la lista
si no estaba ya en ella (ln19-24).

\pagebreak

\subsubsection{Componentes A*}

\paragraph{Estado}~
\index{Algoritmo A*!Estado}

El estado es una estructura de datos que describe la situación
del problema en un punto determinado.
Estos estados deben ser comparables,
debe ser posible dados dos estados conocer si son iguales o distintos.
En el caso del JSP, el estado representa una planificación parcial o completa
en la cual una serie de tareas han sido planificadas:

\begin{itemize}[itemsep=0.25px]
    \item Instante de tiempo en el que comienza cada tarea planificada.
    \item Instante de tiempo futuro en el que cada trabajador estará libre
    (i.e. finaliza la tarea que estaba realizando).
\end{itemize}

El resultado final del JSP será un estado donde todas las tareas han sido planificadas.

\paragraph{Costes}~
\index{Algoritmo A*!Costes}

El algoritmo A* utiliza 3 costes distintos para resolver el problema de optimización:

\subparagraph{Coste G}~
\index{Algoritmo A*!Costes!Coste G}

El coste G (de ahora en adelante $cost_g$) es el coste desde el estado inicial
hasta el estado actual.
Este coste es calculado buscando el mayor tiempo de fin de
las tareas ya planificadas.

\subparagraph{Coste H}~
\index{Algoritmo A*!Costes!Coste H}

El coste H (de ahora en adelante $cost_h$) es el coste estimado desde el estado actual
hasta el estado final.
Este coste es calculado utilizando una función heurística,
que estima el coste.

Idealmente esta función heurística será una cota inferior cuando el problema
sea de minimización y una cota superior cuando sea de maximización.
El heurístico deberá ser entonces diseñado atendiendo al tipo de problema.

\subparagraph{Coste F}~
\index{Algoritmo A*!Costes!Coste F}

El coste F (de ahora en adelante $cost_f$) es el coste estimado desde el estado inicial
hasta el estado final pasando por el estado actual.

Por lo tanto, \[cost_f = cost_g + cost_h\]

\pagebreak

\paragraph{Generación de sucesores}~
\index{Algoritmo A*!Generación de sucesores}

El algoritmo A* debe generar un número de estados sucesores dado un estado cualquiera.
Por lo que será necesario una función que dado un estado retorne este listado de estados.

Un estado con $N$ trabajos por completar ($J_0 \dots J_N$)
tiene $N$ tareas ($T_0 \dots T_N$) que están listas para ser ejecutadas
(sus predecesoras han sido ya completadas).
Este estado generará entonces $N$ estados sucesores
donde en cada uno se planificará una de las tareas
para el primer instante de tiempo posible.
Este primer instante se calcula utilizando el
máximo entre el instante de fin de la tarea predecesora y
el instante en el que el trabajador asignado
para la tarea a planificar $T_x$ queda libre.

\begin{examplebox}
    En el ejemplo anterior (\ref{ssec:A*Example}) con trabajos:
    \begin{enumerate}[start=0, itemsep=0.25px]
        \item (2, 0), (5, 1), (1, 2)
        \item (3, 1), (3, 2), (3, 0)
    \end{enumerate}
    El estado:
    \begin{itemize}[itemsep=0.25px]
        \item Planificación:
        \begin{enumerate}[start=0, itemsep=0.25px]
            \item (0, 3, -1)
            \item (0, -1, -1)
        \end{enumerate}
        \item Estado trabajadores: (2, 8, 0)
    \end{itemize}
    Tiene dos trabajos sin completar, por lo que generará dos sucesores.
    Uno en el que se planifica la primera tarea sin planificar del trabajo 0.
    \begin{itemize}[itemsep=0.25px]
        \item Instante en el que se puede iniciar la tarea: $3 + 5 = 8$
        \item Instante en el que el trabajador está libre: $0$
    \end{itemize}
    Por lo tanto, la tarea comenzará en $max(0, 8) = 8$.
    Y el trabajador estará libre en $8 + 1 = 9$.
    \begin{itemize}[itemsep=0.25px]
        \item Planificación:
        \begin{enumerate}[start=0, itemsep=0.25px]
            \item (0, 3, 8)
            \item (0, -1, -1)
        \end{enumerate}
        \item Estado trabajadores: (2, 8, 9)
    \end{itemize}

    Y otro en el que se planifica la primera tarea sin planificar del trabajo 1.
    \begin{itemize}[itemsep=0.25px]
        \item Instante en el que se puede iniciar la tarea: $0 + 3 = 3$
        \item Instante en el que el trabajador está libre: $0$
    \end{itemize}
    Por lo tanto, la tarea comenzará en $max(0, 3) = 3$.
    Y el trabajador estará libre en $3 + 3 = 6$.
    \begin{itemize}[itemsep=0.25px]
        \item Planificación:
        \begin{enumerate}[start=0, itemsep=0.25px]
            \item (0, 3, -1)
            \item (0, 3, -1)
        \end{enumerate}
        \item Estado trabajadores: (2, 8, 6)
    \end{itemize}
 
\end{examplebox}

\paragraph{Listas de prioridad}~
\index{Algoritmo A*!Listas de prioridad}

El algoritmo A* utiliza dos listas de estados: la lista abierta y la lista cerrada.
La lista cerrada contiene los estados que ya han sido estudiados mientras que
la lista abierta contiene los estados que aún están por estudiar.

Cada vez que se estudia un estado de la lista abierta,
se obtienen sus sucesores que son añadidos a la lista abierta
(siempre y cuando no estén en la lista cerrada)
mientras que el estado estudiado pasa a la lista cerrada.

Los estados de la lista abierta están ordenados en función de su $cost_f$,
de menor a mayor.
De esta forma, se tiene acceso inmediato al elemento con menor $cost_f$.

\pagebreak

\subsection{Equipo de Estudio}
\index{Equipo de Estudio}

Este algoritmo es implementado y optimizado en diversas arquitecturas.
Posteriormente, se realizan comparaciones entre ellas.

\subsubsection{Arquitectura x86}
\index{Equipo de Estudio!Arquitectura x86}

Inicialmente, se realiza una implementación del algoritmo utilizando \Python{}.
Esta versión permite comprobar rápidamente el correcto funcionamiento del mismo
así como llevar a cabo pruebas rápidas sin necesidad de compilación y
estudiar los posibles cuellos de botella del algoritmo.

Posteriormente, se desarrolla una nueva versión del mismo algoritmo
utilizando C++, un lenguaje compilado, imperativo y orientado a objetos
que facilita la paralelización gracias a librerías como 
\href{https://www.openmp.org/}{OpenMP}\@.

Una vez desarrolladas ambas versiones monohilo,
se comienza la implementación de versiones multihilo
que serán posteriormente comparadas.

\subsubsection{FPGA}
\index{Equipo de Estudio!FPGA}

Finalmente, se desarrolla una implementación del algoritmo
diseñado para ser ejecutado en una FPGA\@.
Esta aceleradora, se encuentra embebida en una placa SoC
Zybo Z7 10 acompañada de un procesador ARM\@.

Para realizar esta implementación,
se utiliza el software propio de Xilinx (AMD),
Vitis HDL\@.
Este programa ofrece entre muchas otras herramientas
un sintetizador capaz de transpilar código C++ a Verilog
que puede ser entonces compilado
para ejecutarse en la FPGA\@.

\pagebreak
\section{Método de comparativas}

Las comparativas entre las diferentes implementaciones
del algoritmo se realizan en base a varias características.
Principalmente:

\begin{enumerate}[start=0, itemsep=0.25px]
    \item Tiempo de ejecución.
    \item Calidad de la solución.
\end{enumerate}

Como es lógico, el algoritmo es ejecutado utilizando
distintos datos de entrada múltiples veces.

\begin{notebox}
    La segunda ejecución de cualquier algoritmo suele tender a
    requerir menos tiempo debido al funcionamiento de la caché.
    
    Para evitar este fenómeno, el algoritmo se ejecuta
    siempre $N$ veces ignorando las métricas de la primera ejecución.
\end{notebox}

\pagebreak
\section{Implementación}
\index{Implementación A*}

Tanto \Python como C++ son lenguajes orientados a objetos.
Esta sección contiene las descripciones de las diferentes
clases diseñadas para dar soporte al algoritmo.

\begin{notebox}
El principal contenido de esta investigación es el estudio
de distintas implementaciones paralelas del algoritmo A*,
por ello es necesario tener alguna noción sobre la Implementación
del algoritmo.
\end{notebox}

\subsection{Task}
\index{Implementación A*!Task}

La clase \lstinline{Task} correspone a una tarea a realizar.
Una instancia de esta clase está definida por los atributos:
\begin{itemize}[itemsep=0.25px]
    \item \lstinline{unsigned int duration}: Duración de la tarea.
    \item \lstinline{std::vector<int> qualified_workers}: Listado de trabajadores que pueden realizar la tarea.
\end{itemize}

\subsection{State}
\index{Implementación A*!State}

La clase \lstinline{State} corresponde a un estado (o nodo).
Una instancia de esta clase está definida por los atributos:
\begin{itemize}[itemsep=0.25px]
    \item \lstinline{std::vector<std::vector<Task>> jobs}: Lista de trabajos y tareas a ejecutar.
    \item \lstinline{std::vector<std::vector<int>> schedule}: Planificación actual.
    \item \lstinline{std::vector<int> workers_status}: Instantes en los que cada trabajador queda libre.
\end{itemize}

\begin{notebox}
    Nótese que el atributo \lstinline{std::vector<std::vector<Task>> jobs} será el mismo
    en todos los estados de un mismo problema.
    Por lo que no será necesario revisarlo en
    \lstinline{State::operator==} ni \lstinline{State::operator()}.
    Si el consumo de memoria fuese de importancia,
    sería posible utilizar una referencia para evitar
    almacenar esta estructura múltiples veces.
\end{notebox}

El algoritmo A* requiere que se creen estructuras de datos que contendrán instancias
de la clase \lstinline{State}.
Estas estructuras necesitan que se proporcionen implementaciones para los operadores
\lstinline{State::operator==} y \lstinline{State::operator()} de la clase \lstinline{State}.
Para diseñar las implementaciones de estos operadores
se estudian previamente los atributos que componen la clase \lstinline{State}:

\begin{itemize}[itemsep=0.25px]
    \item \lstinline{std::vector<std::vector<Task>> jobs}: Es igual en todas las
    instancias de \lstinline{State}, por lo que será ignorado.
    \item \lstinline{std::vector<std::vector<int>> schedule}: Proporciona
    información crucial sobre el estado ($cost_g$ y $cost_h$).
    \item \lstinline{std::vector<int> workers_status}: No proporciona
    información alguna sobre los costes,
    pero es necesario para distinguir dos estados diferentes
    ya que es posible que dos estados tengan los mismos costes pero a través de
    planificaciones distintas.
\end{itemize}

Por ello, será necesario definir dos operadores \lstinline{State::operator()}:
uno que sea indiferente al atributo \lstinline{std::vector<int> workers_status}
(\lstinline{StateHash::operator()})
y otro que sí lo tenga en cuenta para distinguir diferentes instancias de \lstinline{State}
(\lstinline{FullHash::operator()}).

\pagebreak
\section{Optimización}
\index{Optimización A*}

\subsection{Algoritmo A* monohilo}
\index{Optimización A*!Monohilo}

La siguiente subsección estudia la optimización
del algoritmo A* sin tener en cuenta el paralelismo,
esto es, se trata de optimizar el rendimiento
monohilo del mismo.

\subsubsection{State}
\index{Optimización A*!Monohilo!State}

La operación \lstinline{operator()} es ejecutada varias veces para cada
\lstinline{State}, este método tiene una complejidad de $O(n^2)$,
por lo que su valor se almacena tras calcularlo por primera vez
en un atributo del propio \lstinline{State}.

Los operadores \lstinline{operator==} necesarios se implementan utilizando
los \lstinline{operator()} correspondientes.
Las funciones hash utilizadas en los \lstinline{operator()}
son resistentes a colisiones,
esto es, $
h(State_a) \ne h(State_b) \iff State_a \ne State_b
$
por lo que se pueden
utilizar para comparar elementos en \lstinline{operator==}.

\pagebreak

\label{ssec:Heuristicos}
\subsubsection{Coste H - Heurístico}
\index{Optimización A*!Monohilo!Heurísticos}

La principal decisión que afectará al tiempo de ejecución
del algoritmo se encuentra en la Implementación
de la función heurística encargada de calcular el coste H.
Este coste se utiliza para seleccionar el siguiente nodo
a expandir, por lo que un buen heurístico es aquel que
mejor dirige al algoritmo en la dirección del nodo objetivo.

El rendimiento y calidad del resultado del algoritmo
dependerán en gran medida de la función seleccionada.
En algunos casos la implementación retornará resultados
óptimos (o cercanos al óptimo) pero requerirá un mayor tiempo
de ejecución, mientras que otras implementaciones
requerirán un menor tiempo de ejecución pero sus resultados
no serán óptimos.
Dependiendo del problema a resolver será conveniente implementar
una función heurística de un tipo u otro.

\paragraph{Heurístico para optimalidad}~
\index{Optimización A*!Monohilo!Heurísticos!Resultado Óptimo}

La siguiente implementación de la función heurística
dirigirá al algoritmo hacia nodos solución que sean óptimos
o se encuentren relativamente cerca del óptimo.

\begin{lstlisting}[language=C++]
unsigned int State::calculate_h_cost() const
{
    std::vector<int> h_costs;
    for (size_t job_idx = 0; job_idx < this->m_jobs.size(); job_idx++)
    {
        h_costs.emplace_back(0);
        std::vector<Task> job = this->m_jobs[job_idx];
        for (size_t task_idx = 0; task_idx < job.size(); task_idx++)
            if (this->get_schedule()[job_idx][task_idx] == -1)
                h_costs[job_idx] += job[task_idx].get_duration();
    }
    auto max_element = std::max_element(h_costs.begin(), h_costs.end());
    return max_element == h_costs.end() ? 0 : *max_element;
}
\end{lstlisting}

La función calcula el tiempo necesario para completar cada trabajo
y retorna el tiempo mayor.

\pagebreak

\paragraph{Heurístico para tiempo}~
\index{Optimización A*!Monohilo!Heurísticos!Rápido}

La siguiente implementación de la función heurística
dirigirá al algoritmo hacia cualquier nodo solución
independientemente de si es óptimo o no.

\begin{lstlisting}[language=C++]
unsigned int State::calculate_h_cost() const
{
    unsigned int unscheduled_tasks_count = 0;
    for (std::size_t job_idx = 0; job_idx < this->m_jobs.size(); job_idx++)
        for (std::size_t task_idx = 0; task_idx < this->m_jobs[job_idx].size(); task_idx++)
            if (this->m_schedule[job_idx][task_idx] == -1)
                unscheduled_tasks_count += this->m_jobs[job_idx][task_idx].get_duration();
    return unscheduled_tasks_count; 
}
\end{lstlisting}

La función calcula el tiempo necesario para completar
las tareas restantes si se ejecutasen una a una
y retorna esta suma.

\begin{notebox}
    A pesar de que ambas implementaciones tienen la misma complejidad ($O(n^2)$),
    un algoritmo A* utilizando de ellas tardará varias magnitudes de tiempo más que
    si utilizase la otra aunque retornará resultados notablemente mejores en algunos casos.
\end{notebox}

\pagebreak

\subsection{Paralelización}
\index{Optimización A*!Multihilo}

En la siguiente subsección
se estudia la paralelización
del algoritmo A*.
Este estudio está compuesto por la descripción y
comparación de distintas alternativas discutidas en
la literatura.

%\begin{figure}
%\begin{center}
%\begin{tikzpicture}[node distance=2cm]
    %\node (A) [startstop] {Inicio};

    %\node (B) [process, right of=A, xshift=2cm] {
        %Inicializar \lstinline{g_costs}, \lstinline{f_costs} y \lstinline{open_set}
    %};

    %\node (C) [decision, below of=B, yshift=-2cm] {
        %¿Se ha encontrado el objetivo?
    %};

    %\node (D) [startstop, right of=C, xshift=3.5cm] {
        %Retornar
    %};

    %\node (E) [process, left of=C, xshift=-3.5cm] {
        %Asignar el primer elemento de \lstinline{open_set}
        %al nodo actual
    %};

    %\node (F) [process, below of=E, yshift=-1cm] {
        %Calcular nodos vecinos del nodo actual
    %};

    %\node (G) [decision, below of=F, yshift=-2cm] {
        %¿Hay vecinos? 
    %};
    
    %\node (H) [process, below of=G, yshift=-2cm] {
        %Calcular el coste G del sucesor actual
    %};

    %\node (I) [decision, right of=H, xshift=3.5cm] {
        %¿Es el mejor coste G que se conoce para este estado?
    %};

    %\node (J) [process, right of=I, xshift=3.5cm] {
        %Guardar coste G y nodo en \lstinline{g_costs} y \lstinline{f_costs}
    %};

    % \node (K) [decision, above of=J, yshift=2cm] {
        % ¿Existe el nodo en el \lstinline{open_set}?
    % };

    % \node (L) [process, left of=K, xshift=-3.5cm] {
        % Insertar en \lstinline{open_set}
    % };

    % \draw [arrow] (A) -- (B);
    % \draw [arrow] (B) -- (C);
    % \draw [arrow] (C) -- node [anchor=north] {Sí} (D);
    % \draw [arrow] (C) -- node [anchor=north] {No} (E);
    % \draw [arrow] (E) -- (F);
    % \draw [arrow] (F) -- (G);
    % \draw [arrow] (G) -- node [anchor=north west] {No} (C);
    % \draw [arrow] (G) -- node [anchor=east] {Sí} (H);
    % \draw [arrow] (H) -- (I);
    % \draw [arrow] (I) -- node [anchor=north east] {No} (G);
    % \draw [arrow] (I) -- node [anchor=north] {Sí} (J);
    % \draw [arrow] (J) -- (K);
    % \draw [arrow] (K) -- node [anchor=north east] {No} (C);
    % \draw [arrow] (K) -- node [anchor=north] {Sí} (L);
    % \draw [arrow] (L) -- (G);
% \end{tikzpicture}
% \end{center}
% \caption{Representación del algoritmo A*}
% \label{fig:AlgoritmoA*}
% \end{figure}

\subsubsection{First Come First Serve (FCFS) Solver}
\index{Optimización A*!Multihilo!First Come First Serve (FCFS) Solver}

Sería posible desarrollar una implementación que paralelice el procesamiento de los nodos,
asignando uno a cada hilo de forma que para $N$ hilos se procesen $N$ nodos
de forma simultánea.
Esta estrategia permite que los hilos procesen los nodos a medida que entran en 
el \lstinline{open_set} (Véase Figura \ref{fig:RepresentacionFCFS}).

\begin{figure}[h]
    \begin{center}
        \begin{tikzpicture}[node distance=2cm]
            \node (00) [process] {\lstinline{open_set}};
            \node (01) [process, right of=00, xshift=6cm] {Procesa nodo};

            \draw [arrow] (00) to [bend left] node [anchor=south] {Extrae nodo} (01);
            \draw [arrow] (01) to [bend left] node [anchor=north] {Inserta vecinos} (00);
        \end{tikzpicture}
    \end{center}
    \caption{Representación de la estrategia FCFS}
    \label{fig:RepresentacionFCFS}
\end{figure}

De cualquier forma, este diseño en particular no tiene por qué reducir el tiempo
requerido para hallar un nodo solución, simplemente tiene la oportunidad de reducirlo
en algunos casos específicos.
Esto se debe a que la única diferencia entre las versiones monohilo y multihilo
es que en la multihilo se procesan más nodos en el mismo tiempo.
(Véase Figura \ref{fig:A*Comparison})

\begin{figure}[h]
\begin{subfigure}{.5\textwidth}
\begin{center}
\begin{tikzpicture}[node distance=1.5cm]
    \node (00) [dot, fill=green!30] {00};
    \node (01) [dot, right of=00] {01};
    \node (02) [dot, right of=01] {02};
    \node (03) [dot, right of=02] {03};

    \node (10) [dot, below of=00] {10};
    \node (11) [dot, right of=10, fill=blue!30] {11};
    \node (12) [dot, right of=11] {12};
    \node (13) [dot, right of=12] {13};

    \node (20) [dot, below of=10] {20};
    \node (21) [dot, right of=20] {21};
    \node (22) [dot, right of=21, fill=blue!30] {22};
    \node (23) [dot, right of=22] {23};

    \node (30) [dot, below of=20] {30};
    \node (31) [dot, right of=30] {31};
    \node (32) [dot, right of=31] {32};
    \node (33) [dot, right of=32, fill=yellow!30] {33};

    \draw [arrow] (00) -- (11);
    \draw [arrow] (11) -- (22);
    \draw [arrow] (22) -- (33);
\end{tikzpicture}
\subcaption{Algoritmo A* monohilo}
\end{center}
\end{subfigure}
\begin{subfigure}{.5\textwidth}
\begin{center}
\begin{tikzpicture}[node distance=1.5cm]
    \node (00) [dot, fill=green!30] {00};
    \node (01) [dot, right of=00, fill=blue!30] {01};
    \node (02) [dot, right of=01] {02};
    \node (03) [dot, right of=02] {03};

    \node (10) [dot, below of=00, fill=blue!30] {10};
    \node (11) [dot, right of=10, fill=blue!30] {11};
    \node (12) [dot, right of=11, fill=blue!30] {12};
    \node (13) [dot, right of=12] {13};

    \node (20) [dot, below of=10] {20};
    \node (21) [dot, right of=20, fill=blue!30] {21};
    \node (22) [dot, right of=21, fill=blue!30] {22};
    \node (23) [dot, right of=22, fill=blue!30] {23};

    \node (30) [dot, below of=20] {30};
    \node (31) [dot, right of=30] {31};
    \node (32) [dot, right of=31, fill=blue!30] {32};
    \node (33) [dot, right of=32, fill=yellow!30] {33};

    \draw [arrow] (00) -- (11);
    \draw [arrow] (00) -- (01);
    \draw [arrow] (00) -- (10);
    \draw [arrow] (11) -- (22);
    \draw [arrow] (11) -- (12);
    \draw [arrow] (11) -- (21);
    \draw [arrow] (22) -- (33);
    \draw [arrow] (22) -- (23);
    \draw [arrow] (22) -- (32);
\end{tikzpicture}
\subcaption{Algoritmo A* multihilo (3 hilos)}
\end{center}
\end{subfigure}
\caption{Comparativa entre algoritmos monohilo y multihilo}
\label{fig:A*Comparison}
\end{figure}

\begin{notebox}
    Nótese que este acercamiento no tiene sincronización entre diferentes iteraciones,
    esto implica que la solución está sujeta a una condición de carrera
    (i.e. la solución depende de qué hilo finalice primero su ejecución).
    Por lo que sería posible ejecutar $N$ veces este algoritmo y obtener
    $N$ soluciones diferentes.
\end{notebox}

\paragraph{Secciones críticas}~

El diseño paralelo propuesto no es sin inconvenientes,
su implementación contiene varias secciones críticas que suponen
una amenaza para el rendimiento del algoritmo.
A continuación se observan cada una de estas secciones y se
analizan las razones por las cuales son necesarias.

\subparagraph{Variables de control de flujo}~

Primero, al paralelizar el algoritmo siguiendo esta estrategia,
se han añadido variables de control compartidas por todos
los hilos que sirven para conocer si se ha resuelto el problema
o no (una variable donde se copia el resultado y
otra que sirve como \italic{flag}).
El acceso a estas variables debe estar controlado
para evitar el acceso simultaneo a las mismas.
De cualquier forma, es improbable que dos hilos tengan
la necesidad de acceder esta sección crítica ya que sólo
se ejecuta una vez por lo que los efectos en el rendimiento serán nulos.
Sería necesario que dos hilos hallasen dos soluciones diferentes al
problema al mismo tiempo.

\subparagraph{\lstinline{open_set}}~

Segundo, el acceso al \lstinline{open_set} también 
debe estar controlado de forma que sólo un hilo
pueda interactuar con la estructura de datos compartida.
Esta interacción se presenta al menos en dos instancias por
cada iteración del bucle principal:
una primera vez para acceder al nodo a procesar
y otra para insertar los nuevos vecinos.
Si bien la obtención del nodo a procesar se realiza en $O(1)$
ya que el \lstinline{open_set} está ordenado y
siempre se accede al nodo en la cabeza de la lista,
la inserción de vecinos no corre la misma suerte.
Para que la lectura del nodo a procesar sea en $O(1)$
el \lstinline{open_set} se mantiene ordenado,
esto implica que la inserción ser haría en $O(n)$
\footnote{Esta implementación utiliza iteradores y
\lstinline{std::deque<T>} para hallar la posición de cada
nuevo elemento e insertarlo en el mismo barrido.}.

\begin{notebox}
    La complejidad de la sección crítica en la que se insertan
    elementos en el \lstinline{open_set}
    tiene como factor la longitud del \lstinline{open_set}. 
    Esto es, a mayor tamaño tenga el \lstinline{open_set},
    mayor tiempo será necesario para resolver la sección crítica.\\

    Nótese que a medida que avanza el programa,
    el tamaño del \lstinline{open_set} crece,
    incrementando la duración de la sección crítica y
    reduciendo la paralelización del algoritmo. 
\end{notebox}

\subsubsection{Batch Solver}
\index{Optimización A*!Multihilo!Batch Solver}

La siguiente estrategia es una evolución del FCFS Solver anterior,
utiliza el mismo principio (los hilos exploran nodos del \lstinline{open_set}
a medida que éste se va llenando),
pero en este caso se implanta una barrera de sincronización en cada iteración.
Esta barrera obliga a los hilos a esperar al resto de sus compañeros
antes de extraer otro nodo del \lstinline{open_set}.

La diferencia más notable entre este acercamiento y el anterior es que
las secciones críticas se ven reducidas porque las secciones paralelas
son menores.
Además, al sincronizar los hilos en cada iteración, ahora no existe ninguna
condición de carrera que pueda alterar el resultado, por lo que
para el mismo problema este algoritmo siempre retornará el mismo resultado
y utilizará la misma ruta para llegar a él.

Se utiliza un \lstinline{std::vector<State>} para almacenar los nodos
a explorar por cada hilo y un \lstinline{std::vector<std::vector<State>>}
para que cada hilo almacene los vecinos que ha encontrado.
Cada uno de estos vectores tiene una longitud igual al número de hilos
de forma que el hilo con ID $N$ tiene asignada la posición $N$ de cada
vector. Véase figura \ref{fig:RepresentacionBatch}.

\begin{figure}[h]
    \begin{center}
        \begin{tikzpicture}[node distance=2cm]
            \node (00) [process] {\lstinline{open_set}};
            \node (01) [process, below of=00] {Nodos a explorar};
            \node (02) [process, below of=01] {Procesa nodo};
            \node (03) [process, below of=02] {Vecinos a insertar};

            \draw [arrow] (00) -- (01);
            
            \draw [arrow] (01.south) -- ([xshift=-15mm]00.south |- 02.north);
            \draw [arrow] (01.south) -- ([xshift=-10mm]00.south |- 02.north);
            \draw [arrow] (01.south) -- ([xshift=-5mm]00.south |- 02.north);
            \draw [arrow] (01.south) -- (00.south |- 02.north);
            \draw [arrow] (01.south) -- ([xshift=15mm]00.south |- 02.north);
            \draw [arrow] (01.south) -- ([xshift=10mm]00.south |- 02.north);
            \draw [arrow] (01.south) -- ([xshift=5mm]00.south |- 02.north);

            \draw [arrow] (02.south) -- (03);
            \draw [arrow] (02.south)+(5mm,0) -- (03);
            \draw [arrow] (02.south)+(-5mm,0) -- (03);
            \draw [arrow] (02.south)+(10mm,0) -- (03);
            \draw [arrow] (02.south)+(-10mm,0) -- (03);
            \draw [arrow] (02.south)+(15mm,0) -- (03);
            \draw [arrow] (02.south)+(-15mm,0) -- (03);

            \draw [arrow] (03) to [bend left=3cm] node [anchor=east] {Inserta vecinos} (00);
        \end{tikzpicture}
    \end{center}
    \caption{Representación de la estrategia Batch}
    \label{fig:RepresentacionBatch}
\end{figure}

\paragraph{Secciones críticas}~

A diferencia de la estrategia FCFS,
no es posible que dos hilos accedan al mismo recurso
de forma simultánea.
Las únicas estructuras de datos compartidas
(los dos \lstinline{std::vector})
ofrecen a los hilos un índice privado al que acceder.
Las secciones críticas de la estrategia FCFS
ahora son ejecutadas por un hilo:
una al registrar los nodos a explorar y
otra al retirar los vecinos e insertarlos en el \lstinline{open_set}.

\subsubsection{Recursive Solver}
\index{Optimización A*!Multihilo!Recursive Solver}

La estrategia propuesta en \cite{Zag17} se basa en la ejecución
simultánea de varias instancias del algoritmo A* en el mismo problema.
\begin{enumerate}[start=0, itemsep=0.25px]
    \item Calcular vecinos del estado inicial.
    \item Asignar un hilo a cada sucesor.
    \item Para cada sucesor, resolver el problema como si fuese el estado inicial.
    \item Recoger resultados obtenidos.
    \item Obtener resultado con menor coste.
    \item Retornar.
\end{enumerate}

Al igual que la solución por batches,
no existe ninguna condición de carrera que permita
al algoritmo retornar resultados diferentes
en varias ejecuciones.
Originalmente cada hilo utiliza sus propias estructuras
de datos, por lo que no existen secciones críticas.
No obstante, sería posible hacer una versión en la que
los distintos hilos compartiesen las estructuras de costes
y el \lstinline{open_set}.
Implementar el algoritmo de esta forma añadiría las
tediosas secciones críticas que podrían ser más
dañinas que beneficiosas.

Este diseño puede ser de gran interés para otros problemas
distintos al JSP donde existan varios estados iniciales,
ya que sería posible calcular una solución del A*
para cada uno de ellos.
El algoritmo permitiría conocer el mejor estado inicial
así como la ruta a seguir para llegar al estado objetivo.

Uno de los posibles problemas que puede presentar esta
estrategia consiste en la posibilidad de que dos hilos
terminen calculando caminos muy similares.
Esto implica que uno de los hilos ha malgastado un tiempo
que podría haber sido invertido en rutas diferentes.
Para resolver este problema, sería necesario que
los hilos compartiesen alguna estructura de datos
para que sean conscientes de lo que está calculando cada uno.

\pagebreak

\subsubsection{Hash Distributed A* (HDA*) Solver}
\index{Optimización A*!Multihilo!Hash Distributed A* (HDA*) Solver}

El algoritmo propuesto en \cite{KFB09}
utiliza tantos \lstinline{open_set} como hilos
y una función hash para asignar cada nodo a uno de los
\lstinline{open_set}.
Cada hilo es `propietario' de uno de los \lstinline{open_set}
y por consecuente, de los nodos que estén contenidos
dentro del mismo.
Cada hilo está encargado de explorar los nodos de su
\lstinline{open_set} y de añadir sus vecinos
al \lstinline{open_set} correspondiente.

El rendimiento de este acercamiento depende en gran medida de la
función hash que se utilice para distribuir a los diferentes nodos.
Una función hash que no sea uniforme
\footnote{Una función hash es uniforme si los valores que retorna
tienen la misma probabilidad de ser retornados.}
distribuirá los nodos de forma poco equitativa
sobrecargando algunos hilos.
Por otro lado, al utilizar varios \lstinline{open_set},
el tiempo de inserción es menor porque tienen un menor tamaño.

\begin{figure}[h]
    \begin{center}
        \begin{tikzpicture}[node distance=4cm]
            \node (00) [stack] {\lstinline{open_set_0}};
            \node (01) [stack, right of=00] {\lstinline{open_set_1}};
            \node (02) [stack, right of=01] {\lstinline{open_set_2}};
            \node (03) [stack, right of=02] {\lstinline{open_set_3}};

            \node (04) [dot, below of=01, yshift=-2cm] {\lstinline{current_state}};

            \node (06) [process, below of=04] {\lstinline{Calculate neighbors}};

            \node (05) [dot, left of=06, yshift=2cm] {\lstinline{n_0}};
            \node (07) [dot, right of=06, yshift=2cm] {\lstinline{n_1}};
            \node (08) [dot, right of=06, xshift=4cm] {\lstinline{n_2}};

            \draw [arrow] (01.south) to node [anchor=west] {\lstinline{pop()}} (04);

            \draw [arrow] (04.south) to node [anchor=west] {\lstinline{process()}} (06);

            \draw [arrow] (06.west) to [bend left] node [anchor=north] {\lstinline{neighbor_0}} (05);
            \draw [arrow] (06.east) to [bend right] node [anchor=west] {\lstinline{neighbor_1}} (07);
            \draw [arrow] (06.east) to node [anchor=north] {\lstinline{neighbor_2}} (08);

            \draw [arrow] (05.north) to node [anchor=east] {\lstinline{insert()}} (00);
            \draw [arrow] (07.north) to node [anchor=east] {\lstinline{insert()}} (02);
            \draw [arrow] (08.north) to node [anchor=east] {\lstinline{insert()}} (03);

       \end{tikzpicture}
    \end{center}
    \caption{Representación de la estrategia HDA*}
    \label{fig:RepresentacionHDA}
\end{figure}
