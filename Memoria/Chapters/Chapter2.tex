\Chapter{Experimentos}{Trabajo y Resultados}

\section{Conjuntos de datos}

Los diferentes conjuntos de datos utilizados para medir el rendimiento
de las diferentes implementaciones han sido obtenidos de
\href{http://jobshop.jjvh.nl/}{(HTTP) Jobshop Instances}
o diseñados a mano.

\subsection{\italic{Jobshop Instances}}

\subsection{Personalizados}

\section{Método de medición}

Todas las versiones imprimen por salida estándar datos que posteriormente son
procesados en formato CSV:

\begin{itemize}[itemsep=0.25px]
    \item Lenguaje
    \item Número de hilos
    \item Porcentaje del trabajo resuelto
    \item Trabajos
    \item Tareas
    \item Trabajadores
    \item Tiempo de ejecución
    \item Planificación
    \item \italic{Makespan}
\end{itemize}

La alta complejidad del JSP implica que un mínimo aumento en el tamaño del problema
puede implicar que el algoritmo no finalice su ejecución en un tiempo polinomial.
Por ello, en lugar de tomar una única medición al inicio y final de la ejecución
se ha optado por utilizar un objeto personalizado que toma mediciones en intervalos
predefinidos.
De esta forma, de una única ejecución se podría obtener:

\begin{itemize}[itemsep=0.25px]
    \item Tiempo de inicio.
    \item Tiempo necesario para resolver el $10\percentsign$ del problema.
    \item Tiempo necesario para resolver el $20\percentsign$ del problema.
    \item \dots
    \item Tiempo necesario para resolver el $90\percentsign$ del problema.
    \item Tiempo necesario para resolver el $100\percentsign$ del problema.
\end{itemize}
Se utiliza una función que se encarga de tomar una medición de tiempo
antes y después de iniciar el algoritmo.

\begin{lstlisting}[language=C++]
class Chronometer
{
private:
    std::chrono::_V2::system_clock::time_point m_start_time;
    std::map<unsigned short, bool> m_goals;
    std::map<unsigned short, double> m_times;
    std::string m_solver_name;

public:
    Chronometer() : Chronometer(
        std::map<unsigned short, bool>(),
        "Unknown Solver") {}
    explicit Chronometer(
        const std::map<unsigned short, bool> &goals,
        std::string const &solver_name) : m_goals(goals),
                                          m_solver_name(solver_name) {}

    void start()
    {
        this->m_start_time = std::chrono::high_resolution_clock::now();
    }
    std::chrono::duration<double> time() const
    {
        return (
            std::chrono::high_resolution_clock::now() -
            this->m_start_time
        );
    }

    void process_iteration(const State &state);
    void log_timestamp(unsigned short goal, const State &state);
    void enable_goals();
    std::map<unsigned short, double> get_timestamps() const;
};
\end{lstlisting}

Esta clase se utiliza para tomar las mediciones de todas las iteraciones
\footnote{Ignorando la primera para calentar la caché}
y posteriormente estos datos se utilizan para calcular tiempos medios de ejecución,
máximos y mínimos.

\section{Resultados}

\section{Análisis}
