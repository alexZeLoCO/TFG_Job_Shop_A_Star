\Chapter{Hipótesis de Partida y Alcance}{Estado del Arte}
\index{Hipótesis de Partida y Alcance}

\section{Objeto de la investigación}
\index{Hipótesis de Partida y Alcance!Objeto de la investigación}

El presente proyecto tiene como objetivo principal descubrir los
beneficios del paralelismo aplicado al algoritmo A*.
Para estudiar el rendimiento de las implementaciones desarrolladas
se utilizará el Job Shop Scheduling Problem.
Adicionalmente, se observará el rendimiento de una implementación
de la misma solución en una FPGA.

La motivación principal para la realización de este proyecto
emana en un interés personal por el diseño, implementación y optimización
de algoritmos aplicables a problemas reales.

El Job Shop Scheduling Problem es un problema de optimización
sobre la planificación de horarios.
Este problema en particular es mundialmente conocido,
ha sido resuelto utilizando un gran abanico de algoritmo diferentes
y ha sido profundamente estudiado.

La resolución del Job Shop Scheduling Problem requiere el diseño e implementación de
un algoritmo capaz de recibir como entrada las descripciones de una plantilla
de trabajadores y un listado de trabajos y tareas a realizar puede ser
aplicable en ámbitos industriales donde la automatización de la creación
de planificaciones pueda ser de interés.

\pagebreak

\section{Estado del arte}
\index{Hipótesis de Partida y Alcance!Estado del arte}

Este proyecto abarca diversos tópicos, cuyas bibliografías
(incluso en individual) tienen una gran extensión.
A pesar de ello, resulta complicado hallar estudios previos sobre implementaciones
paralelas del algoritmo A* enfocadas a la resolución del Job Shop Scheduling Problem
utilizando FPGAs.
Así pues, el punto de partida de este proyecto
se compone principalmente de estudios
sobre los distintos tópicos de forma individual.

El Job Shop Scheduling Problem tiene su origen en la década de 1960,
desde entonces ha sido utilizado frecuentemente (incluso hasta el día de hoy)
como herramienta de medición del rendimiento de algoritmos que sean 
capaces de resolverlo \cite{Man67}.

A lo largo de los años, se han realizado numerosos trabajos con el objetivo
de recoger distintos algoritmos que resuelvan el problema.
Dichos algoritmos provienen de diferentes ámbitos de la computación.
Entre ellos se pueden encontrar búsquedas en grafos,
listas de prioridad, ramificación y poda, algoritmos genéticos,
simulaciones Monte Carlo o
métodos gráficos como diagramas Gantt y Pert.
\cite{Yan77}, \cite{Nil69}, \cite{KTM99}, \cite{BC22}.

El algoritmo A* fue diseñado a finales de la década de 1960
con el objetivo de implementar el enrutamiento de un robot
conocido como \italic{"Shakey the Robot"} \cite{Nil84}.
A* es una evolución del conocido algoritmo de Dijkstra
frecuentemente utilizado también para la búsqueda en grafos.
La principal diferencia entre estos dos algoritmos es el
uso de una función heurística en el A* que `guía' al algoritmo
en la dirección de la solución.
\cite{HNR68}, \cite{MSV13}, \cite{Kon14}.

El algoritmo A* no es propenso a la paralelización,
no existe una implementación simple que aproveche el funcionamiento de
varios procesadores de forma simultanea.
En su lugar existen varias alternativas que paralelizan el algoritmo,
cada una de ellas con sus fortalezas y debilidades.
Estas diferentes versiones serán estudiadas, implementadas y
probadas en esta investigación.
\cite{Zag17}, \cite{WH16}.

El tópico sobre el que menor cantidad de documentación existe
y que supone una mayor curva de aprendizaje es sin lugar a duda
la implementación del algoritmo A* en una FPGA.
A diferencia de este proyecto, la principal fuente de bibliografía
sobre este tópico desarrolla una implementación personalizada del algoritmo
que reporta una aceleración de casi el $400\percentsign$.
\cite{ZJW20}.

\pagebreak

\section{Requisitos}
\index{Hipótesis de Partida y Alcance!Requisitos}

El algoritmo a desarrollar en esta investigación deberá recibir como entrada
una estructura de datos que contenga los trabajos,
para cada trabajo la lista de tareas que lo compone,
para cada tarea su duración y el listado de trabajadores cualificados para realizarla
(generalmente, la longitud de esta lista será 1).

Como resultado, el algoritmo deberá retornar un listado de trabajos,
para cada trabajo el instante de tiempo en el que se inicia cada una de sus tareas
y un listado con los instantes de tiempo en los que cada trabajador quedará libre.
El máximo elemento del listado de instantes de tiempo en los que cada trabajador queda libre
se define como el \italic{makespan}, el tiempo necesario para finalizar todos los trabajos.

\section{Alcance}
\index{Hipótesis de Partida y Alcance!Alcance}

El presente documento describe el problema a resolver en detalle,
los diferentes algoritmos implementados,
observaciones sobre los mismos,
casos de prueba utilizados para obtener métricas de rendimiento
y observaciones sobre las métricas obtenidas.

Entre las observaciones tanto de los algoritmos como de las métricas
obtenidas, se encontrarán razonamientos sobre los resultados así
como explicaciones de las razones por las cuales un algoritmo
presenta un rendimiento distinto a otro.
