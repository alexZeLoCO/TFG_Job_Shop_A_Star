\Chapter{Hipótesis de Partida y Alcance}{Estado del Arte}

\section{Objeto de la investigación}

El presente proyecto tiene como objetivo principal descubrir los
beneficios de paralelizar una implementación del algoritmo A*
diseñado para resolver el Job Shop Scheduling Problem.
Adicionalmente, se observará el rendimiento de una implementación
de la misma solución en una FPGA.

La motivación principal para la realización de este proyecto
emana en un interés personal por el diseño, implementación y optimización
de algoritmos aplicables a problemas reales,
un ejemplo de estos algoritmos sería el A*.

Respecto al Job Shop Scheduling Problem, presenta un problema establecido
años atrás, profundamente estudiado y cuyas soluciones
puden ser obtenidas aplicando diversos algoritmos.

Un algoritmo capaz de recibir como entrada las descripciones de una plantilla
de trabajadores y un listado de trabajos y tareas a realizar puede ser
aplicable en ámbitos industriales donde la automatización de la creación
de planificaciones pueda ser de interés.

\section{Estado del arte}

Este proyecto abarca diversos tópicos, cuyas bibliografías
(incluso en individual) son extensas.
A pesar de ello, resulta complicado hallar estudios previos sobre implementaciones
paralelas del algoritmo A* enfocadas a la resolución del Job Shop Scheduling Problem.
Así pues, el punto de partida de este proyecto
se compone principalmente de bibliografía
sobre los distintos tópicos individuales.

El Job Shop Scheduling Problem tiene su origen en la década de 1960,
desde entonces ha sido utilizado frecuentemente (incluso hasta el día de hoy)
como herramienta de medición del rendimiento de algoritmos
capaces de resolverlo \cite{Man67}.

A lo largo de los años, se han realizado numerosos trabajos con el objetivo
de recoger distintos algoritmos que resuelvan el problema.
Dichos algoritmos provienen de diferentes ámbitos de la computación.
Entre ellos se pueden encontrar búsquedas en grafos,
listas de prioridad, ramificación y poda, algoritmos genéticos,
simulaciones Monte Carlo o
métodos gráficos como diagramas Gantt y Pert.
\cite{Yan77}, \cite{Nil69}, \cite{KTM99}, \cite{BC22}.

El algoritmo A* fue diseñado a finales de la década de 1960
con el objetivo de implementar el enrutamiento de un robot
conocido como \italic{"Shakey the Robot"} (\cite{Nil84}).
A* es una evolución del conocido algoritmo de Dijkstra
frecuentemente utilizado también para la búsqueda en grafos.
La principal diferencia entre estos dos algoritmos es el
uso de una función heurística en el A* que `guía' al algoritmo
en la dirección de la solución.
\cite{HNR68}, \cite{MSV13}, \cite{Kon14}.

El tópico sobre el que menor cantidad de documentación existe
y que supone una mayor curva de aprendizaje es sin lugar a duda
la implementación del algoritmo A* en una FPGA.
A diferencia de este proyecto, la principal fuente de bibliografía
sobre este tópico desarrolla una implementación personalizada del algoritmo
que reporta una aceleración de casi el $400\percentsign$.
\cite{ZJW20}.

\section{Requisitos}

El algoritmo a desarrollar en esta investigación deberá recibir como entrada
una estructura de datos que contenga los trabajos,
para cada trabajo la lista de tareas que lo compone,
para cada tarea su duración y el listado de trabajadores cualificados para realizarla
(generalmente, la longitud de esta lista será 1).

Como resultado, el algoritmo deberá retornar un listado de trabajos,
para cada trabajo el instante de tiempo en el que se inicia cada una de sus tareas
y un listado con los instantes de tiempo en los que cada trabajador quedará libre.
El máximo elemento del listado de instantes de tiempo en los que cada trabajador queda libre
se define como el \italic{makespan}, el tiempo necesario para finalizar todos los trabajos.

\section{Alcance}

El presente documento describe el problema a resolver en detalle,
los métodos utilizados para resolverlo y
los equipos en los que se ejecutan las diferentes versiones de las soluciones.

Entre los contenidos de este documento se encuentran detalles sobre
la implementación de las soluciones, así como
los cuellos de botella hallados, problemas y razonamientos a la hora de
tomar ciertas decisiones en el desarrollo así como estudios teóricos
realizados con el objetivo de hallar inconvenientes de forma preventiva.
